import { BaseRepository, BaseListQuery, PaginatedListResult } from '../../shared/repositories/base.repository';
import type { Knex } from 'knex';
import {
  type Create{{ModuleName}},
  type Update{{ModuleName}},
  type {{ModuleName}},
  type Get{{ModuleName}}Query,
  type List{{ModuleName}}Query,
  type {{ModuleName}}Entity
} from './{{moduleName}}.types';

export interface {{ModuleName}}ListQuery extends BaseListQuery {
  // Smart field-based filters for {{ModuleName}}
  {{#each columns}}
  {{#unless isPrimaryKey}}
  {{#if (eq tsType 'boolean')}}
  {{name}}?: boolean;
  {{else if (eq tsType 'string')}}
  {{name}}?: string;
  {{else if (eq tsType 'number')}}
  {{name}}?: number;
  {{/if}}
  {{#if (isDateField this)}}
  {{name}}_min?: Date;
  {{name}}_max?: Date;
  {{else if (isRangeField this)}}
  {{name}}_min?: number;
  {{name}}_max?: number;
  {{/if}}
  {{/unless}}
  {{/each}}
}

export class {{ModuleName}}Repository extends BaseRepository<{{ModuleName}}, Create{{ModuleName}}, Update{{ModuleName}}> {

  constructor(knex: Knex) {
    super(
      knex,
      '{{tableName}}',
      [
        // Define searchable fields
        {{#each columns}}
        {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
        {{#ifEquals tsType 'string'}}
        '{{@root.tableName}}.{{name}}'{{#unless @last}},{{/unless}}
        {{/ifEquals}}
        {{/unless}}
        {{/each}}
      ],
      [
        // üõ°Ô∏è Explicit UUID fields for validation
        {{#each columns}}
        {{#if (or isPrimaryKey (contains name '_id') (contains dataType 'uuid'))}}
        '{{name}}'{{#unless @last}},{{/unless}}
        {{/if}}
        {{/each}}
      ]
    );
  }

  // Transform database row to entity
  transformToEntity(dbRow: any): {{ModuleName}} {
    if (!dbRow) throw new Error('Cannot transform null database row');

    return {
      {{#each columns}}
      {{name}}: dbRow.{{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    };
  }

  // Transform DTO to database format
  transformToDb(dto: Create{{ModuleName}} | Update{{ModuleName}}): Partial<{{ModuleName}}Entity> {
    const transformed: Partial<{{ModuleName}}Entity> = {};

    {{#each columns}}
    {{#unless isPrimaryKey}}
    {{#unless (eq name 'created_at')}}
    {{#unless (eq name 'updated_at')}}
    if ('{{name}}' in dto && dto.{{name}} !== undefined) {
      {{#if (eq tsType 'Date')}}
      transformed.{{name}} = typeof dto.{{name}} === 'string' ? new Date(dto.{{name}}) : dto.{{name}};
      {{else}}
      transformed.{{name}} = dto.{{name}};
      {{/if}}
    }
    {{/unless}}
    {{/unless}}
    {{/unless}}
    {{/each}}
    // updated_at is handled automatically by database

    return transformed;
  }

  // Custom query with joins if needed
  getJoinQuery() {
    return this.knex('{{tableName}}')
      .select('{{tableName}}.*');
      // Add joins here if needed
      // .leftJoin('other_table', '{{tableName}}.foreign_key', 'other_table.id')
  }

  // UUID validation helper
  private isValidUuid(value: string): boolean {
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidRegex.test(value);
  }

  // Apply custom filters
  protected applyCustomFilters(query: any, filters: {{ModuleName}}ListQuery): void {
    // List of reserved parameters that should not be treated as filters
    const reservedParams = [
      'fields', 'format', 'include',
      // Pagination and sorting parameters
      'page', 'limit', 'sort',
      // Date filtering parameters (handled by custom logic)
      {{#each columns}}
      {{#if (isDateField this)}}
      '{{name}}_min', '{{name}}_max',
      {{/if}}
      {{#if (isRangeField this)}}
      '{{name}}_min', '{{name}}_max',
      {{/if}}
      {{/each}}
    ];
    
    // List of UUID fields that need special handling
    const uuidFields = [{{#each columns}}{{#if (eq sqlType 'uuid')}}'{{name}}'{{#unless @last}}, {{/unless}}{{/if}}{{/each}}];
    
    // Apply general filters with UUID field validation
    Object.keys(filters).forEach(key => {
      if (filters[key] !== undefined && filters[key] !== null && !reservedParams.includes(key)) {
        const value = filters[key];
        
        // Skip empty strings for UUID fields
        if (uuidFields.includes(key) && (value === '' || value === null || value === undefined)) {
          return;
        }
        
        // Validate UUID format for UUID fields
        if (uuidFields.includes(key) && typeof value === 'string' && value !== '') {
          if (!this.isValidUuid(value)) {
            throw new Error(`Invalid UUID format for field '${key}': ${value}`);
          }
        }
        
        // Skip empty strings for regular string fields too
        if (typeof value === 'string' && value.trim() === '') {
          return;
        }
        
        // Apply the filter
        query.where(`{{tableName}}.${key}`, value);
      }
    });

    // Apply specific {{ModuleName}} filters
    {{#each columns}}
    {{#unless isPrimaryKey}}
    {{#if (isDateField this)}}
    // Date field: {{name}}
    if (filters.{{name}} !== undefined && filters.{{name}} !== '') {
      const dateValue = new Date(filters.{{name}});
      {{#if (isDateTime this)}}
      // DateTime field - use exact match
      query.where('{{@root.tableName}}.{{name}}', dateValue);
      {{else}}
      // Date field - match full day (create new Date objects to avoid mutation)
      const startOfDay = new Date(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), 0, 0, 0, 0);
      const endOfDay = new Date(dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), 23, 59, 59, 999);
      query.whereBetween('{{@root.tableName}}.{{name}}', [startOfDay, endOfDay]);
      {{/if}}
    }
    if (filters.{{name}}_min !== undefined && filters.{{name}}_min !== '') {
      query.where('{{@root.tableName}}.{{name}}', '>=', new Date(filters.{{name}}_min));
    }
    if (filters.{{name}}_max !== undefined && filters.{{name}}_max !== '') {
      query.where('{{@root.tableName}}.{{name}}', '<=', new Date(filters.{{name}}_max));
    }
    {{else if (eq tsType 'string')}}
    if (filters.{{name}} !== undefined && filters.{{name}} !== '') {
      query.where('{{@root.tableName}}.{{name}}', filters.{{name}});
    }
    {{else if (isRangeField this)}}
    if (filters.{{name}}_min !== undefined) {
      query.where('{{@root.tableName}}.{{name}}', '>=', filters.{{name}}_min);
    }
    if (filters.{{name}}_max !== undefined) {
      query.where('{{@root.tableName}}.{{name}}', '<=', filters.{{name}}_max);
    }
    {{else}}
    if (filters.{{name}} !== undefined) {
      query.where('{{@root.tableName}}.{{name}}', filters.{{name}});
    }
    {{/if}}
    {{/unless}}
    {{/each}}
  }

  // Apply multiple sort parsing
  protected applyMultipleSort(query: any, sort?: string): void {
    if (sort) {
      if (sort.includes(',')) {
        // Multiple sort format: field1:desc,field2:asc,field3:desc
        const sortPairs = sort.split(',');
        sortPairs.forEach(pair => {
          const [field, direction] = pair.split(':');
          const mappedField = this.getSortField(field.trim());
          const sortDirection = direction?.trim().toLowerCase() === 'asc' ? 'asc' : 'desc';
          query.orderBy(mappedField, sortDirection);
        });
      } else {
        // Single sort field
        const [field, direction] = sort.split(':');
        const mappedField = this.getSortField(field.trim());
        const sortDirection = direction?.trim().toLowerCase() === 'asc' ? 'asc' : 'desc';
        query.orderBy(mappedField, sortDirection);
      }
    } else {
      // Default sort
      query.orderBy(this.getSortField('created_at'), 'desc');
    }
  }

  // Custom sort fields mapping
  protected getSortField(sortBy: string): string {
    const sortFields: Record<string, string> = {
      {{#each columns}}
      {{toCamelCase name}}: '{{@root.tableName}}.{{name}}',
      {{name}}: '{{@root.tableName}}.{{name}}'{{#unless @last}},{{/unless}}
      {{/each}}
    };

    return sortFields[sortBy] || '{{@root.tableName}}.{{#each @root.primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}';
  }

  // Extended find method with options
  async findById(
    id: number | string,
    options: Get{{ModuleName}}Query = {}
  ): Promise<{{ModuleName}} | null> {
    let query = this.getJoinQuery();
    query = query.where('{{tableName}}.{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', id);

    // Handle include options
    if (options.include) {
      const includes = Array.isArray(options.include) ? options.include : [options.include];
      includes.forEach(relation => {
        // TODO: Add join logic for relationships
        // Example: if (relation === 'category') query.leftJoin('categories', 'items.category_id', 'categories.id');
      });
    }

    const row = await query.first();
    return row ? this.transformToEntity(row) : null;
  }

  // Extended list method with specific query type
  async list(query: {{ModuleName}}ListQuery = {}): Promise<PaginatedListResult<{{ModuleName}}>> {
    return super.list(query);
  }

  // Additional business-specific methods
  
  {{#each columns}}
  {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
  {{#if (eq tsType 'string')}}
  async findBy{{toPascalCase name}}({{toCamelCase name}}: string): Promise<{{@root.ModuleName}} | null> {
    const query = this.getJoinQuery();
    const row = await query.where('{{@root.tableName}}.{{name}}', {{toCamelCase name}}).first();
    return row ? this.transformToEntity(row) : null;
  }

  {{/if}}
  {{/unless}}
  {{/each}}

  // ===== ERROR HANDLING: DUPLICATE DETECTION METHODS =====
  {{#if hasUniqueConstraints}}

  {{#each uniqueConstraints.singleField}}
  /**
   * Find by unique field: {{this}}
   * Used for duplicate detection before insert/update
   */
  async findBy{{toPascalCase this}}({{toCamelCase this}}: string | number): Promise<{{@root.ModuleName}} | null> {
    const query = this.getJoinQuery();
    const row = await query.where('{{@root.tableName}}.{{this}}', {{toCamelCase this}}).first();
    return row ? this.transformToEntity(row) : null;
  }

  {{/each}}
  {{#each uniqueConstraints.composite}}
  /**
   * Find by composite unique key: {{#each this}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
   * Used for duplicate detection before insert/update
   */
  async findBy{{#each this}}{{toPascalCase this}}{{#unless @last}}And{{/unless}}{{/each}}(params: { {{#each this}}{{toCamelCase this}}: string | number{{#unless @last}}, {{/unless}}{{/each}} }): Promise<{{@root.ModuleName}} | null> {
    const query = this.getJoinQuery();
    {{#each this}}
    query.where('{{@root.tableName}}.{{this}}', params.{{toCamelCase this}});
    {{/each}}
    const row = await query.first();
    return row ? this.transformToEntity(row) : null;
  }

  {{/each}}
  {{/if}}

  // ===== ERROR HANDLING: DELETE VALIDATION METHODS =====
  {{#if hasForeignKeyReferences}}

  /**
   * Check if record can be deleted
   * Returns foreign key references that would prevent deletion
   */
  async canBeDeleted(id: string | number): Promise<{
    canDelete: boolean;
    blockedBy: Array<{
      table: string;
      field: string;
      count: number;
      cascade: boolean;
    }>;
  }> {
    const blockedBy: Array<{
      table: string;
      field: string;
      count: number;
      cascade: boolean;
    }> = [];

    {{#each foreignKeyReferences}}
    // Check {{table}} references
    const {{toCamelCase table}}Count = await this.knex('{{table}}')
      .where('{{field}}', id)
      .count('* as count')
      .first();

    if (parseInt({{toCamelCase table}}Count?.count as string || '0') > 0) {
      blockedBy.push({
        table: '{{table}}',
        field: '{{field}}',
        count: parseInt({{toCamelCase table}}Count?.count as string || '0'),
        cascade: {{#if cascade}}true{{else}}false{{/if}}
      });
    }

    {{/each}}

    return {
      canDelete: blockedBy.length === 0 || blockedBy.every(ref => ref.cascade),
      blockedBy
    };
  }

  {{/if}}

  // Statistics and aggregation methods
  async getStats(): Promise<{
    total: number;
    active: number;
    inactive: number;
    percentages?: {
      active: number;
      inactive: number;
    };
  }> {
    const stats: any = await this.knex('{{tableName}}')
      .select([
        this.knex.raw('COUNT(*) as total'),
        {{#if hasStatusField}}
        this.knex.raw('COUNT(*) FILTER (WHERE is_active = true) as active_count'),
        this.knex.raw('COUNT(*) FILTER (WHERE is_active = false OR is_active IS NULL) as inactive_count')
        {{else}}
        this.knex.raw('COUNT(*) as active_count'),
        this.knex.raw('0 as inactive_count')
        {{/if}}
      ])
      .first();

    const total = parseInt(stats?.total || '0');
    const active = parseInt(stats?.active_count || '0');
    const inactive = parseInt(stats?.inactive_count || '0');

    return {
      total,
      active,
      inactive,
      percentages: total > 0 ? {
        active: Math.round((active / total) * 100),
        inactive: Math.round((inactive / total) * 100),
      } : undefined,
    };
  }

  // Bulk operations with better type safety
  async createMany(data: Create{{ModuleName}}[]): Promise<{{ModuleName}}[]> {
    const transformedData = data.map(item => this.transformToDb(item));
    const rows = await this.knex('{{tableName}}').insert(transformedData).returning('*');
    return rows.map(row => this.transformToEntity(row));
  }

  // Transaction support for complex operations
  async createWithTransaction(data: Create{{ModuleName}}): Promise<{{ModuleName}}> {
    return this.withTransaction(async (trx) => {
      const transformedData = this.transformToDb(data);
      const [row] = await trx('{{tableName}}').insert(transformedData).returning('*');
      return this.transformToEntity(row);
    });
  }

{{#if (or (eq package 'enterprise') (eq package 'full'))}}

  // ===== ENHANCED CRUD METHODS =====

  /**
   * Get dropdown options with minimal data
   */
  async getDropdownOptions(query: {
    search?: string;
    limit?: number;
    active?: boolean;
    exclude?: (string | number)[];
    include_disabled?: boolean;
  } = {}): Promise<{
    options: Array<{
      value: string | number;
      label: string;
      disabled?: boolean;
      metadata?: Record<string, any>;
    }>;
    total: number;
  }> {
    const { search, limit = 50, active, exclude, include_disabled } = query;
    
    let selectQuery = this.knex('{{tableName}}')
      .select([
        '{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}} as value',
        {{#each columns}}
        {{#if (eq tsType 'string')}}
        {{#if (contains name 'name')}}
        '{{name}} as label'{{#unless @last}},{{/unless}}
        {{/if}}
        {{/if}}
        {{/each}}
      ]);

    // Apply search filter
    if (search) {
      selectQuery = selectQuery.where((builder) => {
        {{#each columns}}
        {{#if (eq tsType 'string')}}
        builder.orWhere('{{name}}', 'ILIKE', `%${search}%`);
        {{/if}}
        {{/each}}
      });
    }

    {{#each columns}}
    {{#if (eq name 'is_active')}}
    // Apply active filter
    if (active !== undefined) {
      selectQuery = selectQuery.where('is_active', active);
    }
    {{/if}}
    {{/each}}

    // Apply exclude filter
    if (exclude && exclude.length > 0) {
      selectQuery = selectQuery.whereNotIn('{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', exclude);
    }

    // Apply limit
    selectQuery = selectQuery.limit(limit);

    // Get total count
    const countQuery = this.knex('{{tableName}}').count('* as count').first();
    
    const [options, countResult] = await Promise.all([
      selectQuery,
      countQuery
    ]);

    return {
      options: options.map(row => ({
        value: row.value,
        label: row.label || `{{ModuleName}} ${row.value}`,
        {{#each columns}}
        {{#if (eq name 'is_active')}}
        disabled: !row.is_active,
        {{/if}}
        {{/each}}
        metadata: {}
      })),
      total: parseInt(countResult?.count as string || '0')
    };
  }

  /**
   * Bulk create with error handling
   */
  async bulkCreate(data: {
    items: Create{{ModuleName}}[];
    options?: {
      skipDuplicates?: boolean;
      continueOnError?: boolean;
    };
  }): Promise<{
    successful: {{ModuleName}}[];
    failed: Array<{
      id?: string | number;
      error: string;
      data?: any;
    }>;
    summary: {
      total: number;
      successful: number;
      failed: number;
    };
  }> {
    const { items, options = {} } = data;
    const { skipDuplicates = false, continueOnError = true } = options;
    
    const successful: {{ModuleName}}[] = [];
    const failed: Array<{ id?: string | number; error: string; data?: any }> = [];

    if (continueOnError) {
      // Process items one by one
      for (const item of items) {
        try {
          const transformedData = this.transformToDb(item);
          const [row] = await this.knex('{{tableName}}').insert(transformedData).returning('*');
          successful.push(this.transformToEntity(row));
        } catch (error: any) {
          failed.push({
            error: error.message,
            data: item
          });
        }
      }
    } else {
      try {
        const transformedData = items.map(item => this.transformToDb(item));
        const rows = await this.knex('{{tableName}}').insert(transformedData).returning('*');
        successful.push(...rows.map(row => this.transformToEntity(row)));
      } catch (error: any) {
        failed.push({
          error: error.message,
          data: items
        });
      }
    }

    return {
      successful,
      failed,
      summary: {
        total: items.length,
        successful: successful.length,
        failed: failed.length
      }
    };
  }

  /**
   * Bulk update with error handling
   */
  async bulkUpdate(data: {
    items: Array<{
      id: string | number;
      data: Update{{ModuleName}};
    }>;
    options?: {
      continueOnError?: boolean;
    };
  }): Promise<{
    successful: {{ModuleName}}[];
    failed: Array<{
      id?: string | number;
      error: string;
      data?: any;
    }>;
    summary: {
      total: number;
      successful: number;
      failed: number;
    };
  }> {
    const { items, options = {} } = data;
    const { continueOnError = true } = options;
    
    const successful: {{ModuleName}}[] = [];
    const failed: Array<{ id?: string | number; error: string; data?: any }> = [];

    for (const item of items) {
      try {
        const transformedData = this.transformToDb(item.data);
        const [row] = await this.knex('{{tableName}}')
          .where('{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', item.id)
          .update(transformedData)
          .returning('*');
        
        if (row) {
          successful.push(this.transformToEntity(row));
        } else {
          failed.push({
            id: item.id,
            error: 'Record not found',
            data: item.data
          });
        }
      } catch (error: any) {
        failed.push({
          id: item.id,
          error: error.message,
          data: item.data
        });
        
        if (!continueOnError) break;
      }
    }

    return {
      successful,
      failed,
      summary: {
        total: items.length,
        successful: successful.length,
        failed: failed.length
      }
    };
  }

  /**
   * Bulk delete with error handling
   */
  async bulkDelete(data: {
    ids: (string | number)[];
    options?: {
      force?: boolean;
      continueOnError?: boolean;
    };
  }): Promise<{
    successful: Array<{ id: string | number }>;
    failed: Array<{
      id?: string | number;
      error: string;
      data?: any;
    }>;
    summary: {
      total: number;
      successful: number;
      failed: number;
    };
  }> {
    const { ids, options = {} } = data;
    const { force = false, continueOnError = true } = options;
    
    const successful: Array<{ id: string | number }> = [];
    const failed: Array<{ id?: string | number; error: string; data?: any }> = [];

    if (continueOnError) {
      // Process IDs one by one
      for (const id of ids) {
        try {
          const deletedCount = await this.knex('{{tableName}}')
            .where('{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', id)
            .del();
          
          if (deletedCount > 0) {
            successful.push({ id });
          } else {
            failed.push({
              id,
              error: 'Record not found'
            });
          }
        } catch (error: any) {
          failed.push({
            id,
            error: error.message
          });
        }
      }
    } else {
      try {
        const deletedCount = await this.knex('{{tableName}}')
          .whereIn('{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', ids)
          .del();
        
        if (deletedCount === ids.length) {
          successful.push(...ids.map(id => ({ id })));
        } else {
          failed.push({
            error: `Expected to delete ${ids.length} records, but deleted ${deletedCount}`
          });
        }
      } catch (error: any) {
        failed.push({
          error: error.message,
          data: ids
        });
      }
    }

    return {
      successful,
      failed,
      summary: {
        total: ids.length,
        successful: successful.length,
        failed: failed.length
      }
    };
  }

  {{#if hasStatusField}}
  /**
   * Bulk status update
   */
  async bulkUpdateStatus(data: {
    ids: (string | number)[];
    status: boolean | string;
    options?: {
      continueOnError?: boolean;
    };
  }): Promise<{
    successful: {{ModuleName}}[];
    failed: Array<{
      id?: string | number;
      error: string;
      data?: any;
    }>;
    summary: {
      total: number;
      successful: number;
      failed: number;
    };
  }> {
    const { ids, status, options = {} } = data;
    const { continueOnError = true } = options;
    
    const successful: {{ModuleName}}[] = [];
    const failed: Array<{ id?: string | number; error: string; data?: any }> = [];

    for (const id of ids) {
      try {
        const [row] = await this.knex('{{tableName}}')
          .where('{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', id)
          .update({ 
            {{#each columns}}
            {{#if (or (eq name 'is_active') (eq name 'status'))}}
            {{name}}: status,
            {{/if}}
            {{/each}}
            updated_at: this.knex.fn.now() 
          })
          .returning('*');
        
        if (row) {
          successful.push(this.transformToEntity(row));
        } else {
          failed.push({
            id,
            error: 'Record not found'
          });
        }
      } catch (error: any) {
        failed.push({
          id,
          error: error.message
        });
        
        if (!continueOnError) break;
      }
    }

    return {
      successful,
      failed,
      summary: {
        total: ids.length,
        successful: successful.length,
        failed: failed.length
      }
    };
  }

  /**
   * Activate/Deactivate/Toggle status
   */
  async updateStatus(
    id: string | number, 
    status: boolean | 'toggle',
    options?: { force?: boolean }
  ): Promise<{
    entity: {{ModuleName}};
    previousStatus: boolean | string;
    newStatus: boolean | string;
  } | null> {
    return this.withTransaction(async (trx) => {
      // Get current entity
      const current = await trx('{{tableName}}')
        .where('{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', id)
        .first();
      
      if (!current) return null;

      {{#each columns}}
      {{#if (or (eq name 'is_active') (eq name 'status'))}}
      const previousStatus = current.{{name}};
      let newStatus: boolean | string;
      
      if (status === 'toggle') {
        newStatus = !previousStatus;
      } else {
        newStatus = status;
      }

      const [row] = await trx('{{../tableName}}')
        .where('{{#each ../primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', id)
        .update({ 
          {{name}}: newStatus,
          updated_at: trx.fn.now() 
        })
        .returning('*');

      return {
        entity: this.transformToEntity(row),
        previousStatus,
        newStatus
      };
      {{/if}}
      {{/each}}
    });
  }
  {{/if}}

  /**
   * Enhanced statistics with growth metrics
   */
  async getEnhancedStats(): Promise<{
    total: number;
    {{#each columns}}
    {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
    {{#if (eq tsType 'boolean')}}
    {{toCamelCase name}}Count: number;
    {{/if}}
    {{/unless}}
    {{/each}}
    percentages?: {
      {{#each columns}}
      {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
      {{#if (eq tsType 'boolean')}}
      {{toCamelCase name}}: number;
      {{/if}}
      {{/unless}}
      {{/each}}
    };
    growth?: {
      daily: number;
      weekly: number;
      monthly: number;
    };
    custom?: Record<string, any>;
  }> {
    const stats = await this.getStats();
    
    // Calculate percentages
    const percentages = stats.total > 0 ? {
      {{#each columns}}
      {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
      {{#if (eq tsType 'boolean')}}
      {{toCamelCase name}}: Math.round((stats.{{toCamelCase name}}Count / stats.total) * 100),
      {{/if}}
      {{/unless}}
      {{/each}}
    } : undefined;

    // Calculate growth (last 30 days)
    const now = new Date();
    const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const lastWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const lastMonth = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    const [dailyCount, weeklyCount, monthlyCount] = await Promise.all([
      this.knex('{{tableName}}').where('created_at', '>=', yesterday).count('* as count').first(),
      this.knex('{{tableName}}').where('created_at', '>=', lastWeek).count('* as count').first(),
      this.knex('{{tableName}}').where('created_at', '>=', lastMonth).count('* as count').first()
    ]);

    const growth = {
      daily: parseInt(dailyCount?.count as string || '0'),
      weekly: parseInt(weeklyCount?.count as string || '0'),
      monthly: parseInt(monthlyCount?.count as string || '0')
    };

    return {
      ...stats,
      percentages,
      growth,
      custom: {}
    };
  }
{{/if}}

{{#if (eq package 'full')}}

  // ===== FULL PACKAGE METHODS =====

  /**
   * Validate data against business rules
   */
  async validateData(data: Create{{ModuleName}} | Update{{ModuleName}}, options?: {
    skipBusinessRules?: boolean;
    context?: Record<string, any>;
  }): Promise<{
    valid: boolean;
    errors: Array<{
      field: string;
      message: string;
      code: string;
      severity: 'error' | 'warning' | 'info';
    }>;
    warnings?: Array<{
      field: string;
      message: string;
    }>;
  }> {
    const errors: Array<{
      field: string;
      message: string;
      code: string;
      severity: 'error' | 'warning' | 'info';
    }> = [];
    const warnings: Array<{
      field: string;
      message: string;
    }> = [];

    // Check for required fields
    {{#each columns}}
    {{#if isRequired}}
    {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
    if (!data.{{name}}) {
      errors.push({
        field: '{{name}}',
        message: '{{humanize name}} is required',
        code: 'REQUIRED_FIELD',
        severity: 'error'
      });
    }
    {{/unless}}
    {{/if}}
    {{/each}}

    // Add business-specific validation here
    
    return {
      valid: errors.length === 0,
      errors,
      warnings: warnings.length > 0 ? warnings : undefined
    };
  }

  /**
   * Check field uniqueness
   */
  async checkUniqueness(
    field: string,
    query: {
      value: string | number;
      excludeId?: string | number;
    }
  ): Promise<{
    unique: boolean;
    conflictId?: string | number;
    suggestions?: string[];
  }> {
    const { value, excludeId } = query;
    
    let checkQuery = this.knex('{{tableName}}')
      .where(field, value);
    
    if (excludeId) {
      checkQuery = checkQuery.whereNot('{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', excludeId);
    }
    
    const existing = await checkQuery.first();
    
    if (!existing) {
      return { unique: true };
    }
    
    // Generate suggestions if not unique
    const suggestions: string[] = [];
    if (typeof value === 'string') {
      for (let i = 1; i <= 3; i++) {
        suggestions.push(`${value}${i}`);
      }
    }
    
    return {
      unique: false,
      conflictId: existing.{{#each primaryKey}}{{this}}{{#unless @last}} || existing.{{/unless}}{{/each}},
      suggestions
    };
  }
{{/if}}
}