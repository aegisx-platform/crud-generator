import * as ExcelJS from 'exceljs';
import type { Borders } from 'exceljs';
import * as csv from 'fast-csv';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { PDFMakeService, PdfExportField } from './pdfmake.service';


export interface ExportField {
  key: string;
  label: string;
  type?: 'string' | 'number' | 'date' | 'boolean' | 'json';
  format?: (value: any) => string;
}

export interface PdfOptions {
  template?: 'standard' | 'professional' | 'minimal' | 'custom';
  pageSize?: 'A4' | 'A3' | 'LETTER' | 'LEGAL';
  orientation?: 'portrait' | 'landscape';
  subtitle?: string;
  showSummary?: boolean;
  groupBy?: string;
  logo?: string;
  preview?: boolean;
}

export interface ExportOptions {
  data: any[];
  fields?: ExportField[];
  filename?: string;
  title?: string;
  metadata?: {
    exportedBy?: string;
    exportedAt?: Date;
    filters?: Record<string, any>;
    totalRecords?: number;
  };
  pdfOptions?: PdfOptions;
}

export class ExportService {
  private readonly tempDir: string;
  private readonly pdfService: PDFMakeService;

  constructor() {
    this.tempDir = path.join(os.tmpdir(), 'aegisx-exports');
    this.pdfService = new PDFMakeService();
    this.ensureTempDir();
  }

  /**
   * Export data to CSV format
   */
  async exportToCsv(options: ExportOptions): Promise<Buffer> {
    const { data, fields, filename = 'export.csv' } = options;

    return new Promise((resolve, reject) => {
      const tempFile = path.join(this.tempDir, `temp-${Date.now()}.csv`);
      const csvStream = csv.format({ headers: true });
      const writeStream = fs.createWriteStream(tempFile);

      csvStream.pipe(writeStream);

      // Prepare headers and data
      const headers = this.getHeaders(fields, data);
      const processedData = this.processDataForExport(data, fields);

      // Write data
      processedData.forEach((row) => csvStream.write(row));
      csvStream.end();

      writeStream.on('finish', () => {
        const buffer = fs.readFileSync(tempFile);
        fs.unlinkSync(tempFile); // Clean up temp file
        resolve(buffer);
      });

      writeStream.on('error', reject);
    });
  }

  /**
   * Export data to Excel format
   */
  async exportToExcel(options: ExportOptions): Promise<Buffer> {
    const { data, fields, title = 'Data Export', metadata } = options;

    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Data');

    const headers = this.getHeaders(fields, data);
    const processedData = this.processDataForExport(data, fields);

    // Add title if provided
    if (title) {
      worksheet.mergeCells('A1', `${String.fromCharCode(64 + headers.length)}1`);
      const titleCell = worksheet.getCell('A1');
      titleCell.value = title;
      titleCell.font = { size: 16, bold: true };
      titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
      worksheet.getRow(1).height = 30;
    }

    // Add metadata if provided
    let currentRow = title ? 3 : 1;
    if (metadata) {
      if (metadata.exportedBy) {
        worksheet.getCell(`A${currentRow}`).value = `Exported by: ${metadata.exportedBy}`;
        currentRow++;
      }
      if (metadata.exportedAt) {
        worksheet.getCell(`A${currentRow}`).value = `Exported at: ${metadata.exportedAt.toLocaleString()}`;
        currentRow++;
      }
      if (metadata.totalRecords !== undefined) {
        worksheet.getCell(`A${currentRow}`).value = `Total records: ${metadata.totalRecords}`;
        currentRow++;
      }
      currentRow++; // Add spacing
    }

    // Add headers
    const headerRow = worksheet.getRow(currentRow);
    headers.forEach((header, index) => {
      const cell = headerRow.getCell(index + 1);
      cell.value = header;
      cell.font = { bold: true };
      cell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE3F2FD' },
      };
      cell.border = this.getCellBorder();
    });

    // Add data rows
    processedData.forEach((row) => {
      currentRow++;
      const dataRow = worksheet.getRow(currentRow);
      headers.forEach((header, index) => {
        const cell = dataRow.getCell(index + 1);
        cell.value = row[header];
        cell.border = this.getCellBorder();
      });
    });

    // Auto-fit columns
    worksheet.columns.forEach((column) => {
      let maxLength = 0;
      column.eachCell?.({ includeEmpty: true }, (cell) => {
        const cellValue = cell.value ? cell.value.toString() : '';
        maxLength = Math.max(maxLength, cellValue.length);
      });
      column.width = Math.min(maxLength + 2, 50);
    });

    return (await workbook.xlsx.writeBuffer()) as Buffer;
  }

  /**
   * Export data to PDF format using PDFMakeService
   */
  async exportToPdf(options: ExportOptions): Promise<Buffer> {
    const {
      data,
      fields,
      filename = 'export.pdf',
      title = 'Data Export',
      metadata,
      pdfOptions,
    } = options;

    // Convert ExportField[] to PdfExportField[]
    const pdfFields: PdfExportField[] | undefined = fields?.map(field => ({
      key: field.key,
      label: field.label,
      type: field.type,
      format: field.format
    }));

    // Use PDFMakeService for advanced PDF generation
    return await this.pdfService.generatePdf({
      data,
      fields: pdfFields,
      title,
      subtitle: pdfOptions?.subtitle,
      metadata,
      template: pdfOptions?.template || 'professional',
      pageSize: pdfOptions?.pageSize || 'A4',
      orientation: pdfOptions?.orientation,
      showSummary: pdfOptions?.showSummary,
      groupBy: pdfOptions?.groupBy,
      logo: pdfOptions?.logo,
      preview: pdfOptions?.preview
    });
  }

  /**
   * Get headers from fields or data
   */
  private getHeaders(fields: ExportField[] | undefined, data: any[]): string[] {
    if (fields && fields.length > 0) {
      return fields.map(field => field.label);
    }

    if (data.length > 0) {
      return Object.keys(data[0]);
    }

    return [];
  }

  /**
   * Process data for export based on fields
   */
  private processDataForExport(data: any[], fields: ExportField[] | undefined): any[] {
    if (!fields || fields.length === 0) {
      return data;
    }

    return data.map(item => {
      const processedItem: any = {};

      fields.forEach(field => {
        let value = item[field.key];

        // Apply custom format if provided
        if (field.format && typeof field.format === 'function') {
          value = field.format(value);
        } else {
          // Default formatting based on type
          if (value === null || value === undefined) {
            value = '';
          } else if (field.type === 'date' && value instanceof Date) {
            value = value.toLocaleDateString();
          } else if (field.type === 'boolean') {
            value = value ? 'Yes' : 'No';
          } else if (field.type === 'json' && typeof value === 'object') {
            value = JSON.stringify(value);
          } else {
            value = String(value);
          }
        }

        processedItem[field.label] = value;
      });

      return processedItem;
    });
  }

  private getCellBorder(): Partial<Borders> {
    return {
      top: { style: 'thin' },
      left: { style: 'thin' },
      bottom: { style: 'thin' },
      right: { style: 'thin' },
    };
  }


  /**
   * Ensure temp directory exists
   */
  private ensureTempDir(): void {
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }
  }
}
