import { FastifyInstance } from 'fastify';
import { createTestApp } from '../../../../shared/test/test-app-helper';
import { {{currentRoute.pascalName}}Create, {{currentRoute.pascalName}}Update } from '../schemas/{{currentRoute.camelName}}.types';

/**
 * {{ModuleName}} Domain Tests
 * 
 * Integration tests for {{domainName}} domain functionality.
 * 
 * Generated on: {{timestamp}}
 */

describe('{{ModuleName}} Domain', () => {
  let app: FastifyInstance;
  
  beforeAll(async () => {
    app = await createTestApp();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('{{currentRoute.pascalName}} Routes', () => {
    let created{{currentRoute.pascalName}}Id: string;

    // Test data factory
    const create{{currentRoute.pascalName}}Data = (): {{currentRoute.pascalName}}Create => ({
      // TODO: Add actual test data based on your schema
      name: `Test {{currentRoute.pascalName}} ${Date.now()}`,
      description: 'Test description',
      {{#if hasStatusField}}{{#each columns}}{{#if (or (eq name 'status') (eq name 'is_active'))}}{{#if (eq jsType 'boolean')}}{{name}}: true{{else}}{{#with (getSafeDefault name jsType)}}{{#if this}}{{../name}}: '{{this}}'{{/if}}{{/with}}{{/if}}{{/if}}{{/each}}{{/if}}
    });

    describe('POST /{{currentRoute.name}}', () => {
      it('should create a new {{currentRoute.name}}', async () => {
        const {{currentRoute.camelName}}Data = create{{currentRoute.pascalName}}Data();

        const response = await app.inject({
          method: 'POST',
          url: '/{{currentRoute.name}}',
          payload: {{currentRoute.camelName}}Data
        });

        expect(response.statusCode).toBe(201);
        
        const body = response.json();
        expect(body.success).toBe(true);
        expect(body.data).toMatchObject({{currentRoute.camelName}}Data);
        expect(body.data.id).toBeDefined();
        expect(body.data.created_at).toBeDefined();
        expect(body.data.updated_at).toBeDefined();

        // Store ID for other tests
        created{{currentRoute.pascalName}}Id = body.data.id;
      });

      it('should validate required fields', async () => {
        const response = await app.inject({
          method: 'POST',
          url: '/{{currentRoute.name}}',
          payload: {} // Empty payload to trigger validation
        });

        expect(response.statusCode).toBe(400);
        
        const body = response.json();
        expect(body.success).toBe(false);
        expect(body.error).toBeDefined();
      });
    });

    describe('GET /{{currentRoute.name}}', () => {
      it('should list {{currentRoute.name}} with pagination', async () => {
        const response = await app.inject({
          method: 'GET',
          url: '/{{currentRoute.name}}?page=1&limit=10'
        });

        expect(response.statusCode).toBe(200);
        
        const body = response.json();
        expect(body.success).toBe(true);
        expect(Array.isArray(body.data)).toBe(true);
        expect(body.pagination).toMatchObject({
          page: 1,
          limit: 10,
          total: expect.any(Number),
          pages: expect.any(Number)
        });
      });

      it('should filter {{currentRoute.name}} by query parameters', async () => {
        const response = await app.inject({
          method: 'GET',
          url: '/{{currentRoute.name}}?{{#if hasStatusField}}{{#each columns}}{{#if (or (eq name 'status') (eq name 'is_active'))}}{{#if (eq jsType 'boolean')}}{{name}}=true{{else}}{{#with (getSafeDefault name jsType)}}{{#if this}}{{../name}}={{this}}{{/if}}{{/with}}{{/if}}&{{/if}}{{/each}}{{/if}}name=Test'
        });

        expect(response.statusCode).toBe(200);
        
        const body = response.json();
        expect(body.success).toBe(true);
        expect(Array.isArray(body.data)).toBe(true);
      });
    });

    describe('GET /{{currentRoute.name}}/:id', () => {
      it('should get {{currentRoute.name}} by ID', async () => {
        const response = await app.inject({
          method: 'GET',
          url: `/{{currentRoute.name}}/${created{{currentRoute.pascalName}}Id}`
        });

        expect(response.statusCode).toBe(200);
        
        const body = response.json();
        expect(body.success).toBe(true);
        expect(body.data.id).toBe(created{{currentRoute.pascalName}}Id);
      });

      it('should return 404 for non-existent {{currentRoute.name}}', async () => {
        const nonExistentId = '550e8400-e29b-41d4-a716-446655440000';
        
        const response = await app.inject({
          method: 'GET',
          url: `/{{currentRoute.name}}/${nonExistentId}`
        });

        expect(response.statusCode).toBe(404);
        
        const body = response.json();
        expect(body.success).toBe(false);
      });

      it('should validate UUID format', async () => {
        const response = await app.inject({
          method: 'GET',
          url: '/{{currentRoute.name}}/invalid-id'
        });

        expect(response.statusCode).toBe(400);
      });
    });

    describe('PUT /{{currentRoute.name}}/:id', () => {
      it('should update {{currentRoute.name}}', async () => {
        const updateData: {{currentRoute.pascalName}}Update = {
          name: 'Updated {{currentRoute.pascalName}} Name',
          description: 'Updated description'
        };

        const response = await app.inject({
          method: 'PUT',
          url: `/{{currentRoute.name}}/${created{{currentRoute.pascalName}}Id}`,
          payload: updateData
        });

        expect(response.statusCode).toBe(200);
        
        const body = response.json();
        expect(body.success).toBe(true);
        expect(body.data.name).toBe(updateData.name);
        expect(body.data.description).toBe(updateData.description);
        expect(body.data.updated_at).toBeDefined();
      });

      it('should return 404 for non-existent {{currentRoute.name}}', async () => {
        const nonExistentId = '550e8400-e29b-41d4-a716-446655440000';
        const updateData: {{currentRoute.pascalName}}Update = {
          name: 'Updated Name'
        };

        const response = await app.inject({
          method: 'PUT',
          url: `/{{currentRoute.name}}/${nonExistentId}`,
          payload: updateData
        });

        expect(response.statusCode).toBe(404);
      });
    });

    describe('DELETE /{{currentRoute.name}}/:id', () => {
      it('should delete {{currentRoute.name}}', async () => {
        const response = await app.inject({
          method: 'DELETE',
          url: `/{{currentRoute.name}}/${created{{currentRoute.pascalName}}Id}`
        });

        expect(response.statusCode).toBe(200);
        
        const body = response.json();
        expect(body.success).toBe(true);
        expect(body.message).toBeDefined();
      });

      it('should return 404 for non-existent {{currentRoute.name}}', async () => {
        const response = await app.inject({
          method: 'DELETE',
          url: `/{{currentRoute.name}}/${created{{currentRoute.pascalName}}Id}` // Try to delete again
        });

        expect(response.statusCode).toBe(404);
      });
    });

    {{#if withEvents}}
    describe('WebSocket Events', () => {
      it('should handle WebSocket connections', async () => {
        // TODO: Add WebSocket testing logic
        // This requires setting up WebSocket test client
      });

      it('should emit events on CRUD operations', async () => {
        // TODO: Add event emission testing
        // This requires event listener setup
      });
    });
    {{/if}}
  });

  describe('{{currentRoute.pascalName}} Service', () => {
    // TODO: Add unit tests for service layer
    it('should validate business rules', () => {
      // Add business logic tests here
    });
  });

  describe('{{currentRoute.pascalName}} Repository', () => {
    // TODO: Add unit tests for repository layer
    it('should handle database operations', () => {
      // Add database operation tests here
    });
  });
});