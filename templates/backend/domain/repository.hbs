import { BaseRepository, BaseListQuery, PaginatedListResult } from '../../../shared/repositories/base.repository';
import type { Knex } from 'knex';
import {
  type Create{{ModuleName}},
  type Update{{ModuleName}},
  type {{ModuleName}},
  type Get{{ModuleName}}Query,
  type List{{ModuleName}}Query,
  type {{ModuleName}}Entity
} from '../types/{{toKebabCase currentRoute.camelName}}.types';

export interface {{ModuleName}}ListQuery extends BaseListQuery {
  // Smart field-based filters for {{ModuleName}}
  {{#each columns}}
  {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
  {{#if (isExactMatchField this)}}
  {{name}}?: {{tsType}};
  {{/if}}
  {{#if (isRangeField this)}}
  {{name}}_min?: {{#if (eq tsType 'Date')}}Date{{else}}{{tsType}}{{/if}};
  {{name}}_max?: {{#if (eq tsType 'Date')}}Date{{else}}{{tsType}}{{/if}};
  {{/if}}
  {{/unless}}
  {{/each}}
}

export class {{ModuleName}}Repository extends BaseRepository<{{ModuleName}}, Create{{ModuleName}}, Update{{ModuleName}}> {

  constructor(knex: Knex) {
    super(
      knex,
      '{{tableName}}',
      [
        // Define searchable fields based on intelligent detection
        {{#each columns}}
        {{#if (isSearchableField this)}}
        '{{@root.tableName}}.{{name}}'{{#unless @last}},{{/unless}}
        {{/if}}
        {{/each}}
      ],
      [], // explicitUUIDFields
      {
        // Field configuration for automatic timestamp and audit field management
        hasCreatedAt: {{#if (hasColumn columns 'created_at')}}true{{else}}false{{/if}},
        hasUpdatedAt: {{#if (hasColumn columns 'updated_at')}}true{{else}}false{{/if}},
        hasCreatedBy: {{#if (hasColumn columns 'created_by')}}true{{else}}false{{/if}},
        hasUpdatedBy: {{#if (hasColumn columns 'updated_by')}}true{{else}}false{{/if}},
      }
    );
  }

  // Transform database row to entity
  transformToEntity(dbRow: any): {{ModuleName}} {
    if (!dbRow) throw new Error('Cannot transform null database row');

    return {
      {{#each columns}}
      {{name}}: dbRow.{{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    };
  }

  // Transform DTO to database format
  transformToDb(dto: Create{{ModuleName}} | Update{{ModuleName}}): Partial<{{ModuleName}}Entity> {
    const transformed: Partial<{{ModuleName}}Entity> = {};

    {{#each columns}}
    {{#unless isPrimaryKey}}
    {{#unless (eq name 'created_at')}}
    {{#unless (eq name 'updated_at')}}
    if ('{{name}}' in dto && dto.{{name}} !== undefined) {
      {{#if (eq tsType 'Date')}}
      transformed.{{name}} = typeof dto.{{name}} === 'string' ? new Date(dto.{{name}}) : dto.{{name}};
      {{else}}
      transformed.{{name}} = dto.{{name}};
      {{/if}}
    }
    {{/unless}}
    {{/unless}}
    {{/unless}}
    {{/each}}
    // updated_at is handled automatically by database

    return transformed;
  }

  // Custom query with joins if needed
  getJoinQuery() {
    return this.knex('{{tableName}}')
      .select('{{tableName}}.*');
      // Add joins here if needed
      // .leftJoin('other_table', '{{tableName}}.foreign_key', 'other_table.id')
  }

  // Apply custom filters
  protected applyCustomFilters(query: any, filters: {{ModuleName}}ListQuery): void {
    // Apply base filters first
    super.applyCustomFilters(query, filters);

    // Apply specific {{ModuleName}} filters based on intelligent field categorization
    {{#each columns}}
    {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
    {{#if (isExactMatchField this)}}
    if (filters.{{name}} !== undefined) {
      query.where('{{@root.tableName}}.{{name}}', filters.{{name}});
    }
    {{/if}}
    {{#if (isRangeField this)}}
    if (filters.{{name}}_min !== undefined) {
      query.where('{{@root.tableName}}.{{name}}', '>=', filters.{{name}}_min);
    }
    if (filters.{{name}}_max !== undefined) {
      query.where('{{@root.tableName}}.{{name}}', '<=', filters.{{name}}_max);
    }
    {{/if}}
    {{/unless}}
    {{/each}}
  }

  // Apply multiple sort parsing
  protected applyMultipleSort(query: any, sort?: string): void {
    if (sort) {
      if (sort.includes(',')) {
        // Multiple sort format: field1:desc,field2:asc,field3:desc
        const sortPairs = sort.split(',');
        sortPairs.forEach(pair => {
          const [field, direction] = pair.split(':');
          const mappedField = this.getSortField(field.trim());
          const sortDirection = direction?.trim().toLowerCase() === 'asc' ? 'asc' : 'desc';
          query.orderBy(mappedField, sortDirection);
        });
      } else {
        // Single sort field
        const [field, direction] = sort.split(':');
        const mappedField = this.getSortField(field.trim());
        const sortDirection = direction?.trim().toLowerCase() === 'asc' ? 'asc' : 'desc';
        query.orderBy(mappedField, sortDirection);
      }
    } else {
      // Default sort
      query.orderBy(this.getSortField('created_at'), 'desc');
    }
  }

  // Custom sort fields mapping
  protected getSortField(sortBy: string): string {
    const sortFields: Record<string, string> = {
      {{#each columns}}
      {{toCamelCase name}}: '{{@root.tableName}}.{{name}}'{{#unless @last}},{{/unless}}
      {{/each}}
    };

    return sortFields[sortBy] || '{{@root.tableName}}.id';
  }

  // Extended find method with options
  async findById(
    id: number | string,
    options: Get{{ModuleName}}Query = {}
  ): Promise<{{ModuleName}} | null> {
    let query = this.getJoinQuery();
    query = query.where('{{tableName}}.{{#each primaryKey}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}', id);

    // Handle include options
    if (options.include) {
      const includes = Array.isArray(options.include) ? options.include : [options.include];
      includes.forEach(relation => {
        // TODO: Add join logic for relationships
        // Example: if (relation === 'category') query.leftJoin('categories', 'items.category_id', 'categories.id');
      });
    }

    const row = await query.first();
    return row ? this.transformToEntity(row) : null;
  }

  // Extended list method with specific query type
  async list(query: {{ModuleName}}ListQuery = {}): Promise<PaginatedListResult<{{ModuleName}}>> {
    return super.list(query);
  }


  // Business-specific methods for unique/important fields
  
  {{#each columns}}
  {{#unless (or isPrimaryKey (eq name 'created_at') (eq name 'updated_at'))}}
  {{#if (isDisplayField this)}}
  async findBy{{toPascalCase name}}({{toCamelCase name}}: {{tsType}}): Promise<{{@root.ModuleName}} | null> {
    const query = this.getJoinQuery();
    const row = await query.where('{{@root.tableName}}.{{name}}', {{toCamelCase name}}).first();
    return row ? this.transformToEntity(row) : null;
  }

  {{/if}}
  {{/unless}}
  {{/each}}

  // ===== ERROR HANDLING: DUPLICATE DETECTION METHODS =====
  {{#if hasUniqueConstraints}}

  {{#each uniqueConstraints.singleField}}
  /**
   * Find by unique field: {{this}}
   * Used for duplicate detection before insert/update
   */
  async findBy{{toPascalCase this}}({{toCamelCase this}}: string | number): Promise<{{@root.ModuleName}} | null> {
    const query = this.getJoinQuery();
    const row = await query.where('{{@root.tableName}}.{{this}}', {{toCamelCase this}}).first();
    return row ? this.transformToEntity(row) : null;
  }

  {{/each}}
  {{#each uniqueConstraints.composite}}
  /**
   * Find by composite unique key: {{#each this}}{{this}}{{#unless @last}}, {{/unless}}{{/each}}
   * Used for duplicate detection before insert/update
   */
  async findBy{{#each this}}{{toPascalCase this}}{{#unless @last}}And{{/unless}}{{/each}}(params: { {{#each this}}{{toCamelCase this}}: string | number{{#unless @last}}, {{/unless}}{{/each}} }): Promise<{{@root.ModuleName}} | null> {
    const query = this.getJoinQuery();
    {{#each this}}
    query.where('{{@root.tableName}}.{{this}}', params.{{toCamelCase this}});
    {{/each}}
    const row = await query.first();
    return row ? this.transformToEntity(row) : null;
  }

  {{/each}}
  {{/if}}

  // ===== ERROR HANDLING: DELETE VALIDATION METHODS =====
  {{#if hasForeignKeyReferences}}

  /**
   * Check if record can be deleted
   * Returns foreign key references that would prevent deletion
   */
  async canBeDeleted(id: string | number): Promise<{
    canDelete: boolean;
    blockedBy: Array<{
      table: string;
      field: string;
      count: number;
      cascade: boolean;
    }>;
  }> {
    const blockedBy: Array<{
      table: string;
      field: string;
      count: number;
      cascade: boolean;
    }> = [];

    {{#each foreignKeyReferences}}
    // Check {{table}} references
    const {{toCamelCase table}}Count = await this.knex('{{table}}')
      .where('{{field}}', id)
      .count('* as count')
      .first();

    if (parseInt({{toCamelCase table}}Count?.count as string || '0') > 0) {
      blockedBy.push({
        table: '{{table}}',
        field: '{{field}}',
        count: parseInt({{toCamelCase table}}Count?.count as string || '0'),
        cascade: {{#if cascade}}true{{else}}false{{/if}}
      });
    }

    {{/each}}

    return {
      canDelete: blockedBy.length === 0 || blockedBy.every(ref => ref.cascade),
      blockedBy
    };
  }

  {{/if}}

  {{#if smartStats}}
  // Smart Statistics based on detected field patterns
  async getStats(): Promise<{
    total: number;
    {{#if hasStatusField}}
    active?: number;
    inactive?: number;
    percentages?: {
      active: number;
      inactive: number;
    };
    {{/if}}
    {{#if hasDateField}}
    recentlyCreated?: number;
    recentlyUpdated?: number;
    {{/if}}
  }> {
    const baseQuery = this.knex('{{tableName}}');
    
    // Build select fields based on detected patterns
    const selectFields = [
      this.knex.raw('COUNT(*) as total')
    ];

    {{#if hasStatusField}}
    // Add status-based statistics if status field detected
    selectFields.push(
      {{#if statusColumns.length}}
      this.knex.raw('COUNT(*) FILTER (WHERE {{#each statusColumns}}{{name}} = true{{#unless @last}} OR {{/unless}}{{/each}}) as active_count'),
      this.knex.raw('COUNT(*) FILTER (WHERE {{#each statusColumns}}{{name}} = false OR {{name}} IS NULL{{#unless @last}} OR {{/unless}}{{/each}}) as inactive_count')
      {{else}}
      this.knex.raw('COUNT(*) as active_count'),
      this.knex.raw('0 as inactive_count')
      {{/if}}
    );
    {{/if}}

    {{#if hasDateField}}
    // Add date-based statistics if date fields detected
    selectFields.push(
      {{#each dateColumns}}
      {{#if (eq name 'created_at')}}
      this.knex.raw("COUNT(*) FILTER (WHERE {{name}} >= NOW() - INTERVAL '7 days') as recently_created"){{#unless @last}},{{/unless}}
      {{/if}}
      {{#if (eq name 'updated_at')}}
      this.knex.raw("COUNT(*) FILTER (WHERE {{name}} >= NOW() - INTERVAL '7 days') as recently_updated"){{#unless @last}},{{/unless}}
      {{/if}}
      {{/each}}
    );
    {{/if}}

    const stats: any = await baseQuery
      .select(selectFields)
      .first();

    const total = parseInt(stats?.total || '0');
    {{#if hasStatusField}}
    const active = parseInt(stats?.active_count || '0');
    const inactive = parseInt(stats?.inactive_count || '0');
    {{/if}}

    return {
      total,
      {{#if hasStatusField}}
      active,
      inactive,
      percentages: total > 0 ? {
        active: Math.round((active / total) * 100),
        inactive: Math.round((inactive / total) * 100),
      } : undefined,
      {{/if}}
      {{#if hasDateField}}
      recentlyCreated: parseInt(stats?.recently_created || '0'),
      recentlyUpdated: parseInt(stats?.recently_updated || '0'),
      {{/if}}
    };
  }
  {{else}}
  // Basic Statistics - count only
  async getStats(): Promise<{
    total: number;
  }> {
    const stats: any = await this.knex('{{tableName}}')
      .select([
        this.knex.raw('COUNT(*) as total')
      ])
      .first();

    return {
      total: parseInt(stats?.total || '0'),
    };
  }
  {{/if}}

  // Bulk operations with better type safety
  async createMany(data: Create{{ModuleName}}[]): Promise<{{ModuleName}}[]> {
    const transformedData = data.map(item => this.transformToDb(item));
    const rows = await this.knex('{{tableName}}').insert(transformedData).returning('*');
    return rows.map(row => this.transformToEntity(row));
  }

  // Transaction support for complex operations
  async createWithTransaction(data: Create{{ModuleName}}): Promise<{{ModuleName}}> {
    return this.withTransaction(async (trx) => {
      const transformedData = this.transformToDb(data);
      const [row] = await trx('{{tableName}}').insert(transformedData).returning('*');
      return this.transformToEntity(row);
    });
  }
}